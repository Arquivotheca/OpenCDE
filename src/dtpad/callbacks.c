
/* Begin user code block <abstract> */
/* End user code block <abstract> */

/**
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * BuilderXcessory PRO Version 6.2
 * Code Generator Xcessory 6.2 (08/06/08)  
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));

/* Includes for callbacks */
#include <math.h>
#include <Xm/XmAll.h>
#include <stdlib.h>
#include <ctype.h>
#include "utilities.h"
#include "creation.h"

void
BxManageCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	manage_widget(w, "BxManageCB", (char *) client_data);
}

void
BxExitCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	unsigned long exit_code; 
	
	exit_code = (unsigned long) client_data;
	
	exit(exit_code);
}

void
BxUnmanageCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *name;
	Widget widget;
		
	name = (char *) client_data;
	widget = get_widget_by_name(w, "BxUnmanageCB", name);
	
	XtUnmanageChild(widget);
}

void
newDocCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	XmString str;
	Widget widget;
	
	widget = get_document_text(w, "newDocCB");
	XmTextSetString(widget, "");
	
	widget = get_widget_by_name(w, "newDocCB", "lineTextField");
	XmTextFieldSetString(widget, "");
	
	update_message(w, "newDocCB", "Created new empty file.");
	set_save_path(NULL);
	set_been_saved(False);
	
	update_document_linecount(w, "newDocCB");
	update_window_title(w, "newDocCB");
}

void
fileOpenCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *c_path;
	XmFileSelectionBoxCallbackStruct *res;
	
	res = (XmFileSelectionBoxCallbackStruct *) call_data; 
	c_path = XmStringUnparse(res->value, 
	    NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL); 
	load_file(w, "fileOpenCB", c_path);

	free(c_path);
	XtUnmanageChild(w);
}

void
includeFileCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *file_data, *c_path;
	Widget widget;
	XmFileSelectionBoxCallbackStruct *res;
	XmTextPosition pos;
	
	res = (XmFileSelectionBoxCallbackStruct *) call_data; 
	c_path = XmStringUnparse(res->value, 
	    NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL); 
	file_data = get_file_contents(w, "fileOpenCB", c_path);
	widget = get_document_text(w, "fileOpenCB");
	pos = XmTextGetInsertionPosition(widget);
	XmTextInsert(widget, pos, file_data);
	
	update_document_linecount(w, "includeFileCB");
	update_message(w, "fileOpenCB", "Included file.");
	
	XtFree(c_path);
	XtFree(file_data);
	XtUnmanageChild(w);
}

void
statusBarToggleCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	Widget widget;
	XmToggleButtonCallbackStruct *cbs;
	
	cbs = (XmToggleButtonCallbackStruct *)call_data;
	widget = get_widget_by_name(w, "statusBarToggleCB", "statusBar");
	
	switch (cbs->set) {
		case XmSET:
			XtManageChild(widget);
			break;
		default:
			XtUnmanageChild(widget);
			break;
	}
}

void
saveAsCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *path;
	XmFileSelectionBoxCallbackStruct *res;
	
	res = (XmFileSelectionBoxCallbackStruct *) call_data; 
	path = XmStringUnparse(res->value, 
	    NULL, XmCHARSET_TEXT, XmCHARSET_TEXT, NULL, 0, XmOUTPUT_ALL);
	    
	set_save_path(path);
	if (EXIT_SUCCESS == save_file(w, "saveAsCB")) XtUnmanageChild(w);
	XtFree(path);
}

void
saveCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	Widget widget;
	
	if (NULL == get_save_path())
		manage_widget(w, "saveCB", "saveAsFileSelectionBox");
	else 
		save_file(w, "saveCB");
}

void
editCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	int i;
	char *s;
	long action;
	Time time;
	Widget widget;
	XButtonEvent *event;
	XmPushButtonCallbackStruct *acs;
	XmTextPosition left, right;
	
	action = (long) client_data;
	acs = (XmPushButtonCallbackStruct *) call_data; 
	event = (XButtonEvent *) acs->event;
	time = event->time;
	widget = get_document_text(w, "editCB");
	
	switch (action) {
		case EDIT_CUT:
			XmTextCut(widget, time);
			break;
		case EDIT_COPY:
			XmTextCopy(widget, time);
			break;
		case EDIT_PASTE:
			XmTextPaste(widget);
			break;
		case EDIT_DELETE:
			XmTextRemove(widget);
			break;
		case EDIT_CLEAR:
			edit_clear(widget);
			break;
			if (False == XmTextGetSelectionPosition(widget, 
			    &left, &right)) 
				break; 
			s = calloc(1 + right - left, sizeof(char));
			if (NULL == s) {
				perror("Dtpad (calloc)");
				exit(1);
			}
			for (i = 0; i < right - left; i++) s[i] = ' ';
			s[right - left] = '\0';
			XmTextReplace(widget, left, right, s);
			XtFree(s);
			break;
		default:
			break;
	}
}

void
findDlgCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	long reason;
	XmPushButtonCallbackStruct *acs;
	
	reason = (long) client_data;
	acs = (XmPushButtonCallbackStruct *) call_data;
	
	switch (reason) {
		case FNDLG_FIND:
			document_find(w, "findDlgCB", acs->event, "stringNotFoundMessageBox");
			break;
		case FNDLG_CHANGE:
			document_change(w, "findDlgCB", acs->event);
			break;
		case FNDLG_CHANGEALL:
			document_changeall(w, "findDlgCB", acs->event);
			break;
		default:
			break;
	}
}

void
overstrikeToggleCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *cb;
	Widget doc_w, docw_w, overstrike_lbl_w;
	XmString s;
	XmToggleButtonCallbackStruct *acs;
	
	cb = "overstrikeToggleCB";
	acs = (XmToggleButtonCallbackStruct *)call_data;
	doc_w = get_widget_by_name(w, cb, "documentText");
	docw_w = get_widget_by_name(w, cb, "documentTextWrapped");
	overstrike_lbl_w = get_widget_by_name(w, "overstrikeToggleCB",
	    "overstrikeLabel"); 
	XtCallActionProc(doc_w, "toggle-overstrike", NULL, NULL, 0);
	XtCallActionProc(docw_w, "toggle-overstrike", NULL, NULL, 0);
	
	switch (acs->set) {
		case XmSET:
			s = XmStringCreateLocalized("Overstrike");
			XtVaSetValues(overstrike_lbl_w, 
			    XmNlabelString, s, NULL); 
			break;
		default:
			s = XmStringCreateLocalized("Insert");
			XtVaSetValues(overstrike_lbl_w,
			    XmNlabelString, s, NULL); 
			break;
	}
	
	XmStringFree(s);
}

void
backupSaveToggleCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	XmToggleButtonCallbackStruct *acs;

	acs = (XmToggleButtonCallbackStruct *) call_data;
	
	switch (acs->set) {
		case XmSET:
			set_backup_on_save(True);
			break;
		default:
			set_backup_on_save(False);
			break;
	}
}

void
wrapToFitToggleCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *cb;
	Widget sw_w, sww_w;
	XmToggleButtonCallbackStruct *acs;
	
	acs = (XmToggleButtonCallbackStruct *) call_data;
	cb = "wrapToFitToggleCB";
	
	sw_w = get_widget_by_name(w, cb, "textWindow");
	sww_w = get_widget_by_name(w, cb, "textWindowWrapped");
	
	switch (acs->set) {
		case XmSET:
			XtManageChild(sww_w);
			XtUnmanageChild(sw_w);
			break;
		default:
			XtManageChild(sw_w);
			XtUnmanageChild(sww_w);
			break;
	}
}

void
lineTextFieldActivateCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	short line, rows, cols;
	int conv;
	char *cb, *buf, *linestr;
	Widget doc_w, line_w;
	XmTextPosition pos;
	
	cb = "lineTextFieldActivateCB";
	doc_w = get_document_text(w, cb);
	line_w = get_widget_by_name(w, cb, "lineTextField");
	XtVaGetValues(doc_w,
	    XmNrows, &rows,
	    XmNcolumns, &cols,
	    NULL);
	buf = XmTextGetString(doc_w);
	linestr = XmTextFieldGetString(line_w);
	conv = atoi(linestr);
	
	if (conv > rows) {
		manage_widget(w, cb, "lineOutOfRangeMessageBox");
		goto Cleanup;
	}
	
	line = (short) conv;
	
	pos = line_to_position(buf, line, rows, cols);
	XmTextSetInsertionPosition(doc_w, pos);
	
Cleanup:
	XtFree(linestr);
	XtFree(buf);
}

void
BxVerifyNumericCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	int i, len;
	XmTextVerifyCallbackStruct *acs;
	char *text;
	
	acs = (XmTextVerifyCallbackStruct *) call_data;
	text = acs->text->ptr;
	len = acs->text->length;
	
	for (i = 0; i < len; i++) {
		if (!isdigit(text[i])) {
			acs->doit = False;
			return;
		}
	}
}

void
docWrapModifyCB( Widget w, XtPointer client_data, 
 		XtPointer call_data)
{
	char *cb, *ptr;
	char buf[2];
	int length;
	Boolean res;
	Dimension doc_edge, char_width;
	Position x, y;
	XmRenderTable rtbl;
	XmString s;
	XmTextPosition pos;
	XmTextVerifyCallbackStruct *acs;
	
	acs = (XmTextVerifyCallbackStruct *) call_data;
	cb = "docModifyCB";
	
	if (XmCR_MODIFYING_TEXT_VALUE != acs->reason)
		return;
		
	length = acs->text->length;
	ptr = acs->text->ptr;
	
	if (0 == length)
		return;
	
	pos = acs->startPos;
	res = XmTextPosToXY(w, pos, &x, &y);
	
	if (False == res) {
		fprintf(stderr, 
		    "Could not grab character position coordinates, ignoring.\n");
		return;
	}
	
	XtVaGetValues(w, 
	    XmNwidth, &doc_edge, 
	    XmNrenderTable, &rtbl,
	    NULL);
	
	if (1 == length) {
		buf[0] = *(acs->text->ptr); buf[1] = '\0';
		s = XmStringCreateLocalized(buf);
		char_width = XmStringWidth(rtbl, s);
		if  (doc_edge <= x + 2*char_width) {
			XtRealloc(acs->text->ptr, ++length);
			(acs->text->ptr)[1] = (acs->text->ptr)[0];
			(acs->text->ptr)[0] = '\n';
			acs->text->length = length;
		}
		XmStringFree(s);
		return;
	}
	
	batch_wrap(w, cb, acs->text->ptr, &length, pos);
	acs->text->length = length;
}
